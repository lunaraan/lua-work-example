OpenEgg.client.lua

local MarketplaceService = game:GetService("MarketplaceService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local SoundService = game:GetService("SoundService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local playerScripts = player:WaitForChild("PlayerScripts")

local UIEffects = require(ReplicatedStorage:WaitForChild("Modules").UIModules.UIEffects)
local EggsConfig = require(ReplicatedStorage:WaitForChild("Modules").Configs.EggsConfig)
local RaritiesConfig = require(ReplicatedStorage:WaitForChild("Modules").Configs.RaritiesConfig)
local SoundManager = require(ReplicatedStorage:WaitForChild("Modules").SoundManager)
local PetsConfig = require(ReplicatedStorage:WaitForChild("Modules").Configs.PetsConfig)
local Utils = require(ReplicatedStorage:WaitForChild("Modules").Utils)
local Shop = require(ReplicatedStorage:WaitForChild("Modules").Shop)
local PlayerGuiModule = require(playerScripts:WaitForChild("PlayerGuiModule"))

local camera = workspace.CurrentCamera

local eggs = workspace:WaitForChild("Eggs")
local petRfs = ReplicatedStorage:WaitForChild("RemoteFunctions").PetFunctions

local canHatch = false
local isHatching = false
local eggGui = PlayerGuiModule.GetGui("EggGui")

local onErrorClient = ReplicatedStorage.RemoteEvents.DisplayError.OnErrorClient

local function DisplayEgg(object, xOffset)
    local VIEW_DISTANCE_OFFSET: number = -9.5
    local zOrientation = object:FindFirstChild("ZOrientation") or Instance.new("NumberValue")
    return RunService.PreRender:Connect(function()
        if object then
            local ANGULAR_CFRAME = CFrame.Angles(0, 0, math.rad(zOrientation.Value))
            local OFFSET_CFRAME = CFrame.new(xOffset, 0, VIEW_DISTANCE_OFFSET) * ANGULAR_CFRAME
            object.CFrame = camera.CFrame * OFFSET_CFRAME
        end
    end)
end

local function DisplayPet(object, xOffset)
    local VIEW_DISTANCE_OFFSET: number = -8
    local yOrientation = object:FindFirstChild("YOrientation")
    local yPosition = object:FindFirstChild("YPosition")
    return RunService.PreRender:Connect(function()
        if object then
            local ANGULAR_CFRAME = CFrame.Angles(0, math.rad(yOrientation.Value), 0)
            local OFFSET_CFRAME = CFrame.new(xOffset, yPosition.Value, VIEW_DISTANCE_OFFSET) * ANGULAR_CFRAME * CFrame.Angles(0, math.rad(180), 0)
            object:PivotTo(camera.CFrame * OFFSET_CFRAME)
        end
    end)
end

local function DisplayEggBillboard(enabled)
    eggGui.EggBillboard.Enabled = enabled
    if eggGui.EggBillboard.Adornee == nil then
        eggGui.EggBillboard.Enabled = false
    end
end

local function DisplayPetStats(petData, petOrder, eggName)
    local pet = petData.PetData
    local petDisplay = eggGui.PetDisplay
	local petFrame = petDisplay["Pet" .. tostring(petOrder)]
	local petConfig = PetsConfig[pet.KeyName]

	local petImage = PetsConfig.GetPetIcon(pet.KeyName, pet.Tier)

	if pet.Tier == "Rainbow" then
		local rainbowConnection = UIEffects.Rainbowify(petFrame.PetImage)
		task.delay(3, function()
			rainbowConnection:Disconnect()
		end)
	else
		petFrame.PetImage.ImageColor3 = Color3.fromRGB(255, 255, 255)
	end
	
    petFrame.PetImage.Image = petImage.Image
    petFrame.PetName.Text = if pet.Tier == "Normal" then petConfig.Name else pet.Tier .. " " .. pet.Name
    petFrame.PetName.UIGradient.Color = Utils.TableToClrSeq(RaritiesConfig[pet.Tier])
    petFrame.Rarity.Text = pet.Rarity .. "!"
    petFrame.Rarity.UIGradient.Color = Utils.TableToClrSeq(RaritiesConfig[pet.Rarity])
    petFrame.Visible = true
end

local function HidePetStats(petOrder)
    local petDisplay = eggGui.PetDisplay
    local petFrame = petDisplay["Pet" .. tostring(petOrder)]
    petFrame.Visible = false
end

local function AnimatePet(eggName, petData, xOffset, petOrder)
    local petModel = petData.PetModel:Clone()
    local petScale = Instance.new("NumberValue")

    local yOrientation = Instance.new("NumberValue")
    yOrientation.Name = "YOrientation"
    yOrientation.Value = 0
    yOrientation.Parent = petModel

    local yPosition = Instance.new("NumberValue")
    yPosition.Name = "YPosition"
    yPosition.Value = 0
    yPosition.Parent = petModel

    local originalPetScale = petModel:GetScale()

    local connection = DisplayPet(petModel, xOffset)

    local petPopUp = TweenService:Create(petScale, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
        Value = originalPetScale,
    })
    local petTweenDown = TweenService:Create(yPosition, TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {
        Value = -20,
    })
    local petSpin = TweenService:Create(yOrientation, TweenInfo.new(1.35, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {
        Value = 720
    })

    -- Hacky solution to fake tween the pet model
    local petScaleChanged = petScale.Changed:Connect(function(value)
        petModel:ScaleTo(value)
    end)

    petModel.Parent = workspace
    DisplayPetStats(petData, petOrder, eggName)

    if petData.PetData.Tier == "Rainbow" then
        PetsConfig.AddTempRainbowEffect(petModel)
    end

    -- Animate the entire pet to pop up
    petModel:ScaleTo(0.01)
    petPopUp:Play()
    petPopUp.Completed:Wait()
    petScaleChanged:Disconnect()

    task.wait(0.2)
    petSpin:Play()
    petSpin.Completed:Wait()
    task.wait(0.3)
    petTweenDown:Play()
    HidePetStats(petOrder)
    isHatching = false
    PlayerGuiModule:ShowUI()
    DisplayEggBillboard(true)

    -- Remove the pet after 2 seconds
    task.delay(2, function()
        connection:Disconnect()
        petModel:Destroy()
    end)
end

local function EmitEggParticles(egg, petData)
    local pet = petData.PetData
    local attachment = Instance.new("Attachment")
    local particles = ReplicatedStorage.Particles.EggHatchParticles:Clone()

    local function SetNeonParticles()
        particles.LightEmission = 0.5
    end

    if pet.Tier ~= "Normal" then
        SetNeonParticles()
        particles.Color = Utils.TableToClrSeq(RaritiesConfig[pet.Tier])
    else
        particles.Color = Utils.TableToClrSeq(RaritiesConfig[pet.Rarity])
    end

    attachment.CFrame += Vector3.new(0, 0.65, 0)
    attachment.Parent = egg
    particles.Parent = attachment
    particles:Emit(125)
end

local function AnimateEgg(eggName, petData, xOffset, petOrder)
    local egg = EggsConfig.GetEggMesh(eggName)

    local zOrientationInstance = Instance.new("NumberValue")
    zOrientationInstance.Name = "ZOrientation"
    zOrientationInstance.Parent = egg

    local connection = DisplayEgg(egg, xOffset)
    local originalEggSize = egg.Size

    local guiBlacklist = { eggGui }
    PlayerGuiModule:HideUI(guiBlacklist)

    egg.Size = Vector3.new(0, 0, 0)

    local eggPopUp = TweenService:Create(egg, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
        Size = originalEggSize
    })
    local resetOrientation = TweenService:Create(zOrientationInstance, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {
        Value = 0
    })

    local eggExplode = TweenService:Create(egg, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {
        Size = originalEggSize * 1.6,
        Transparency = 1
    })
    local eggPopDown = TweenService:Create(egg, TweenInfo.new(0.2, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
        Size = originalEggSize / 1.4
    })

    eggPopUp:Play()
    eggPopUp.Completed:Wait()

    for i = 1, 20 do
        local Z_ORIENTATION = if i % 2 == 0 then 30 else -30
        local BASE_TWEEN_TIME = 0.4
        local tweenTime = math.clamp(BASE_TWEEN_TIME / i, 0.05, BASE_TWEEN_TIME)
        local shakeTween = TweenService:Create(zOrientationInstance, TweenInfo.new(tweenTime, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {
            Value = Z_ORIENTATION
        })

        shakeTween:Play()
        shakeTween.Completed:Wait()
    end

    resetOrientation:Play()
    eggPopDown:Play()
    eggPopDown.Completed:Wait()
    task.wait(0.1)
    eggExplode:Play()
    EmitEggParticles(egg, petData)
    SoundManager:Play(SoundService.SoundEffects.PetHatch)

    -- Remove the egg and disconnect the function after 3.5 seconds
    task.delay(3.5, function()
        connection:Disconnect()
        egg:Destroy()
    end)
    task.spawn(AnimatePet, eggName, petData, xOffset, petOrder)
end

local function HatchEgg(eggName)
    local pet, error = petRfs.HatchEgg:InvokeServer(eggName)
    if not pet or pet == "Error" then
        if error == "Not enough storage!" then
            MarketplaceService:PromptGamePassPurchase(player, Shop.PassIds.MoreStorage)
        end
        onErrorClient:Fire(error)
        isHatching = false
        return
    end
    DisplayEggBillboard(false)
    task.spawn(AnimateEgg, eggName, pet, 0, 1)
end

local function HatchTripleEggs(eggName)
    local pets, error = petRfs.HatchTripleEggs:InvokeServer(eggName)
    if not pets or pets == "Error" then
        if error == "PromptPurchase" then
            MarketplaceService:PromptGamePassPurchase(player, Shop.PassIds.TripleEggs)
        elseif error == "Not enough storage!" then
            MarketplaceService:PromptGamePassPurchase(player, Shop.PassIds.MoreStorage)
            onErrorClient:Fire(error)
        else
            onErrorClient:Fire(error)
        end
        isHatching = false
        return
    end
    DisplayEggBillboard(false)
    task.spawn(AnimateEgg, eggName, pets[1], 0, 1)
    task.spawn(AnimateEgg, eggName, pets[2], -5.25, 2)
    task.spawn(AnimateEgg, eggName, pets[3], 5.25, 3)
end

-- <<<<<<<<< Setting input up >>>>>>>>>
local HATCH_ONE_KEY = Enum.KeyCode.E
local HATCH_TRIPLE_KEY = Enum.KeyCode.R

local buttons = eggGui.EggBillboard.Buttons
local openOneButton = buttons.OpenOne
local openTripleButton = buttons.OpenTriple

local initialSizeOne, initialSizeTriple = openOneButton.Size, openTripleButton.Size
local initialColorOne, initialColorTriple = openOneButton.BackgroundColor3, openTripleButton.BackgroundColor3

local eggName = ""

local function HatchOne()
    if not isHatching then
        isHatching = true
        HatchEgg(eggName)
    end
end

local function HatchTriple()
    if not isHatching then
        isHatching = true
        HatchTripleEggs(eggName)
    end
end

eggGui.EggBillboard.Buttons.OpenOne.ButtonArea.MouseButton1Click:Connect(function()
    HatchOne()
end)

eggGui.EggBillboard.Buttons.OpenTriple.ButtonArea.MouseButton1Click:Connect(function()
    HatchTriple()
end)

UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if gameProcessedEvent or not canHatch then return end
    if input.KeyCode == HATCH_ONE_KEY then
        PlayerGuiModule:TweenButtonDown(openOneButton, initialSizeOne)
    elseif input.KeyCode == HATCH_TRIPLE_KEY then
        PlayerGuiModule:TweenButtonDown(openTripleButton, initialSizeTriple)
    end
end)

UserInputService.InputEnded:Connect(function(input, gameProcessedEvent)
    if gameProcessedEvent or not canHatch then return end
    if input.KeyCode == HATCH_ONE_KEY then
        PlayerGuiModule:TweenButtonUp(openOneButton, initialSizeOne, initialColorOne)
        HatchOne()
    elseif input.KeyCode == HATCH_TRIPLE_KEY and not isHatching then
        PlayerGuiModule:TweenButtonUp(openTripleButton, initialSizeTriple, initialColorTriple)
        HatchTriple()
    end
end)

-- <<<<<<<<< Looping through eggs >>>>>>>>>
for _, egg in eggs:GetChildren() do
    local bounds = egg:WaitForChild("Bounds")
    local hatchPetBound = bounds:WaitForChild("HatchPetBound")

    hatchPetBound.Touched:Connect(function(object)
        local playerTouched = Players:GetPlayerFromCharacter(object.Parent)
        if playerTouched == player then
            canHatch = true
            eggName = egg.Name
        end
    end)

    hatchPetBound.TouchEnded:Connect(function(object)
        local playerTouched = Players:GetPlayerFromCharacter(object.Parent)
        if playerTouched == player then
            canHatch = false
        end
    end)
end